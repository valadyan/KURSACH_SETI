# KURSACH_SETI
qt/
Каталог Kseti содержит два подкаталога KURSACH_SETI-выступает в качестве сервера,  SETI_USER- в качестве пользователя.
Между сервером и пользователем с помощью UDP-сокета устанавливается связь, по которой мы передаём в определённой последовательности информацию о расположении окружностей. 
У сервера в отдельном потоке (class MyWorkThread) генерируется физика движения объектов, и тут же формируется пакет для передачи по сокету. Структура данных такая,  что первое число типа size_t—число объектов, а дальнейшая информация разбивается на блоки длинной в sizeof(int)--где первое и второе число—координаты, а 3е-- радиус.
            out<<circles->size();
            for(auto i: *circles){
                i->editab();
                out<<i->a;
                qDebug()<<i->a;
                out<<i->b;
                out<<i->r;
            }

Учитывая, то что объектов может быть большое количество, а сеть нагруженна-- к процессу формирования и отсылки данных был добавлен паттерн двойной буфферизации (см.  class DataBuf). Класс реализован для отсылаемых по сокету сырых данных. Соблюдены все принципы сия паттерна: покуда сокет отправляет первую партию данных —ассинхронно вычисляются другие.
class DataBuf: public QObject
{Q_OBJECT
    std::shared_ptr<QByteArray> buffers1/*{std::shared_ptr<QByteArray>(),std::shared_ptr<QByteArray>()}*/;
    std::shared_ptr<QByteArray> buffers2;
    std::shared_ptr<std::shared_ptr<QByteArray>> current_/*&buffers_*/;
    std::shared_ptr<std::shared_ptr<QByteArray>> next_/*&(buffers_+1)*/;
    void swap() {
      std::shared_ptr<std::shared_ptr<QByteArray>> temp = current_;
      current_ = next_;
      next_ = temp;
    }
public:
    explicit DataBuf()/*:current_(&buffers_[0]), next_(&buffers_[1])*/{
        buffers1=std::shared_ptr<QByteArray>(new QByteArray());
        buffers2=std::shared_ptr<QByteArray>(new QByteArray());
        current_= std::shared_ptr<std::shared_ptr<QByteArray>>(new std::shared_ptr<QByteArray>(buffers1.get()));
        next_=std::shared_ptr<std::shared_ptr<QByteArray>>(new std::shared_ptr<QByteArray>(buffers2.get()));
    }
    QByteArray getBuffer() { return **current_; }//for socket
    QByteArray* getBufferPoint(){ return (*current_).get(); }//for thread
public slots:
    void swapSlot(){swap();qDebug()<<"swaped";}
};

 Все объекты окружностей инстанцируют class MyKrug и пушатся в лист, указатель которого передаётся в отдельный поток для вычислений.
Что касается физики. Рассмотрим сначала движение на примере одной окружности. Визуально оно происходит за счёт быстрой смены картинки, то есть за определённое время рисуется прямоугольник, а в нём окружность. И в каждом последующем кадре меняется положение окружности. 
class krug
{
int a; -нынешняя координата центра окружности по х
int b; -нынешняя координата центра окружности по у
int a2;-предыдущий х
int b2; -предыдущий у
int r;
short int kef_a;-понадобится для направления окружности 
short int kef_b;
…
};
Принцип работы:
формируется массив объектов(окружностей), конструктор задаёт все данные рандомно, кроме радиуса.
for(;;) одно выполнение-один кадр
{
putbar();-рисуется прямоугольник
for(int i=0; i<N; i++)-для каждого объекта выполняются/
{
k[i].putkrug();/сама его рисовка 
k[i].editab();/обработка его следующей координаты(эту функцию я разберу ниже)
}
kchek(k);-проверяет не столкнулись ли окружности(тоже разберу)
delay(time);
}
Класс содержит функцию editab().Возможно была возможность сделать всё поумнее, но так сложилось исторически что для обработки координат используется 20 if-ов…
В общем, в функции шарик в зависимости от своих данных, находит свой if, который задаёт ему дальнейшее движение. Пример одного из условий 
if ((a>a2) && (b>b2) && !((b>=(470-r)) || (a>=(630-r))) && !((b>=(470-r)) && (a>=(630-r))))
{
a2=a;-делаем нынешнее предыдущим 
b2=b;
downr();-меняем направление на вниз-вправо(подобные функции имеют говорящие названия)
return 1;-так исторически сложилось
}
Данный оператор подойдёт для окружности движущейся вниз вправо-((a>a2) && (b>b2)), и она будет «проваливаться» в этот оператор каждый раз, пока не ударится об правую или нижнюю границу-!((b>=(470-r)) || (a>=(630-r))), или об правый нижний угол-!((b>=(470-r)) && (a>=(630-r)))). В двух последних условиях стоят именно > и <, т.к в большинстве случаев шарик немного «ныряет» за границу(но это незаметно глазу). Цифры 470 и 630 в этих условиях это координаты углов нашего прямоугольника, я не видел смысла заменять их переменными, т.к режим в котором работает графическая консоль не позволяет менять размер, и просто выдаёт окошко 480х640. Поэтому оставил цифры…
Функция kchek(k). В ней я прописал физику упругого контакта 2ух окружностей. Сами окружности рассматриваем как не точечные(импульс одной будет передаваться другой по прямой соединяющей их центры), а мерой инертности будет выступать собственный радиус(тоесть p=rV).
void kchek(krug *pk)-посылаем в качестве параметра указатель на массив объектов
{
for(int i=0; i<N-1; i++)-ищем какие окружности столкнулись 
for(int w=i+1; w<N; w++)
if ((pk[i].r+pk[w].r)>=(sqrt(pow((pk[i].a-pk[w].a), 2)+pow((pk[i].b-pk[w].b), 2))))-справа записана теорема пифагора с координатами шариков, и это всё условие столкновения(не «=» опять потому что один шарик может заходить за границы другого)
{
int ia2=pk[i].a; -опять делаем нынешнее предыдущим
int ib2=pk[i].b;
int wa2=pk[w].a;
int wb2=pk[w].b;
pk[i].a=(pk[i].a-pk[i].a2+pk[w].r/pk[i].r*sqrt(pow(pk[w].kef_a, 2)+pow(pk[w].kef_b, 2))*(pk[i].a-pk[w].a)/(pk[w].r+pk[i].r)+pk[i].a);-формула выводится на фото снизу 
pk[i].b=(pk[i].b-pk[i].b2+pk[w].r/pk[i].r*sqrt(pow(pk[w].kef_a, 2)+pow(pk[w].kef_b, 2))*(pk[i].b-pk[w].b)/(pk[w].r+pk[i].r)+pk[i].b);
pk[i].a2=ia2;
pk[i].b2=ib2;
эти же действия зеркально производим для 2ого шарика
pk[w].a=(pk[w].a-pk[w].a2+pk[i].r/pk[w].r*sqrt(pow(pk[i].kef_a, 2)+pow(pk[i].kef_b, 2))*(pk[w].a-ia2)/(pk[i].r+pk[w].r)+pk[w].a);
pk[w].b=(pk[w].b-pk[w].b2+pk[i].r/pk[w].r*sqrt(pow(pk[i].kef_a, 2)+pow(pk[i].kef_b, 2))*(pk[w].b-ib2)/(pk[i].r+pk[w].r)+pk[w].b);
pk[w].a2=wa2;
pk[w].b2=wb2;
pk[i].kef_a=abs(pk[i].a-ia2);-пересчитываем коэффициенты 
pk[i].kef_b=abs(pk[i].b-ib2);
pk[w].kef_a=abs(pk[w].a-wa2);
pk[w].kef_b=abs(pk[w].b-wb2);
}
}
Т.к весь функционал этого класса для отрисовки у пользоветаля не нужен-- была создана структура Krug с 3мя полями под описанные ранее блоки в датаграмме. 
